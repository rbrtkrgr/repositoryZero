name: Signed Commit Test

on:
  workflow_dispatch:

jobs:
  add-file:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          ref: "main"
      - name: Make Change(s)
        run: |
          echo "testing" >> newfile.txt
          
      - name: Detect changed files
        id: changes
        run: |
          git config --global user.email "rbrtkrgr@icloud.com"
          git config --global user.name "rbrtkrgr"
          git add .

          CHANGED_FILES=$(git diff --staged --name-only)
          
          echo "Changed files: $CHANGED_FILES"
          echo "files=$CHANGED_FILES" >> $GITHUB_OUTPUT
      - name: Prepare CreateCommitOnBranch payload
        id: prepare-payload
        run: |
          FILES=$(echo "${{ steps.changes.outputs.files }}" | tr " " "\n")
          ADDITIONS=""
          for FILE in $FILES; do
            CONTENT=$(cat "$FILE" | base64 | tr -d '\n')
            ADDITIONS+=$(jq -n --compact-output --arg path "$FILE" --arg contents "$CONTENT" '{"path":$path,"contents":$contents}')
            ADDITIONS+=","
          done
          ADDITIONS=${ADDITIONS%,}
          echo "additions=[$ADDITIONS]" >> $GITHUB_OUTPUT

      - name: Get the latest commit SHA
        id: get-sha
        run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
        
      - name: Add File and Commit
        run: |
          export GH_TOKEN=${{secrets.PAT}}
        
          REPO=${{github.repository}}
          BRANCH=${{github.ref_name}}
          MESSAGE="Adding newfile.txt"
          PARENT_COMMIT_SHA=${{steps.get-sha.outputs.sha}}
          ADDITIONS2=${{steps.prepare-payload.outputs.additions}}
          ADDITIONS='[{path:"newfile.txt",contents:"dGVzdGluZwo="}]'


          # imagine that `additions` came from some other process and was a large array
          jq --null-input -c \
             --argjson additions '[{ "path": "newfile.txt", "contents": "dGVzdGluZwo=" }]' \
             '$additions' |\
              sed -e 's/"path"/path/g' -e 's/"contents"/contents/g' \
             > additions.gql
          
          # now that `sed` has stripped quotes from keys, I can substitute into a query
          cat <<EOF > mutation.gql
          mutation(
            \$branch: String!
            \$message: String!
            \$repo: String!
            \$sha: GitObjectID!
          ) {
            createCommitOnBranch(
              input: {
                branch: {
                  repositoryNameWithOwner: \$repo,
                  branchName: \$branch
                },
                expectedHeadOid: \$sha,
                fileChanges: {
                  additions: $(cat additions.gql)
                }
                message: {
                  headline: \$message
                }
             }
            ) {
              commit {
                oid
              }
            }
          }
          EOF
          
          # and finally I can invoke the query with primitive variables
          gh api graphql \
             -F branch="$BRANCH" \
             -F repo="$REPO" \
             -F message="$MESSAGE" \
             -F sha="$PARENT_COMMIT_SHA"  \
             -F query=@mutation.gql
